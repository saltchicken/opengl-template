#include "graphics/renderers/ComputeRenderer.h"
#include "core/Settings.h"
#include "core/Time.h"
#include "utils/Log.h"
#include "utils/ResourceManager.h"
#include <glad/glad.h>

ComputeRenderer::ComputeRenderer() = default;
ComputeRenderer::~ComputeRenderer() {
  if (m_texture_id != 0) {
    glDeleteTextures(1, &m_texture_id);
  }
}

bool ComputeRenderer::init(const Config &config) {
  glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

  // 1. Load shaders and mesh
  m_compute_shader = ResourceManager::get_shader(config.compute_shader_name);
  m_draw_shader = ResourceManager::get_shader(config.compute_draw_shader_name);
  m_quad_mesh = ResourceManager::get_primitive("quad");

  if (!m_compute_shader || !m_draw_shader || !m_quad_mesh) {
    Log::error("ComputeRenderer failed to load resources.");
    return false;
  }

  // 2. Create the output texture
  create_texture(config.window_width, config.window_height);

  Log::info("ComputeRenderer initialized.");
  return true;
}

void ComputeRenderer::create_texture(unsigned int width, unsigned int height) {
  if (m_texture_id != 0) {
    glDeleteTextures(1, &m_texture_id);
  }

  m_texture_width = width;
  m_texture_height = height;

  glGenTextures(1, &m_texture_id);
  glBindTexture(GL_TEXTURE_2D, m_texture_id);
  // Use RGBA32F for high precision color values
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, m_texture_width, m_texture_height,
               0, GL_RGBA, GL_FLOAT, NULL);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glBindTexture(GL_TEXTURE_2D, 0);
}

void ComputeRenderer::update(float delta_time) {
  // 1. Use the compute shader
  m_compute_shader->use();
  m_compute_shader->set_float("u_time", Time::get_total_time());

  // 2. Bind the texture as an image for writing
  // The first '0' is the image unit, which corresponds to 'layout(binding=0,
  // ...)' in the shader.
  glBindImageTexture(0, m_texture_id, 0, GL_FALSE, 0, GL_WRITE_ONLY,
                     GL_RGBA32F);

  // 3. Dispatch the compute shader
  // The work group size is 8x8, defined in the shader. We divide the
  // texture size by the workgroup size to get the number of groups to dispatch.
  glDispatchCompute(m_texture_width / 8, m_texture_height / 8, 1);

  // 4. Add a memory barrier
  // This ensures that the compute shader has finished writing to the texture
  // before we try to read from it in the drawing phase.
  glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void ComputeRenderer::draw(Scene &scene, unsigned int screen_width,
                           unsigned int screen_height) {
  // Check if window was resized
  if (screen_width != m_texture_width || screen_height != m_texture_height) {
    create_texture(screen_width, screen_height);
  }

  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_DEPTH_TEST);

  m_draw_shader->use();

  // m_draw_shader->set_int("u_texture", 0); // NOTE: This is not needed

  // Bind the texture generated by the compute shader for reading
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, m_texture_id);

  m_quad_mesh->draw(*m_draw_shader);
}
