#version 430 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct AffineTransform {
    mat4 matrix;
};

layout(std430, binding = 0) readonly buffer TransformsBuffer {
    AffineTransform transforms[];
} transform_buffer;

layout(std430, binding = 1) writeonly buffer PointsBuffer {
    vec4 points[];
} point_buffer;

uniform float u_time;
uniform int u_iterations;
uniform float u_twist_strength;
uniform float u_spiral_strength;
// --- NEW: Uniform to control the spherical variation strength ---
uniform float u_spherical_strength;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= point_buffer.points.length()) {
        return;
    }

    vec2 seed = vec2(id, u_time);
    vec4 current_pos = vec4(random(seed) * 2.0 - 1.0, 
                            random(seed.yx) * 2.0 - 1.0, 
                            random(seed.xx) * 2.0 - 1.0, 1.0);
    
    int num_transforms = transform_buffer.transforms.length();

    for (int i = 0; i < u_iterations; ++i) {
        // --- STEP 1: LINEAR transform ---
        float rand = random(current_pos.xy + seed);
        int transform_index = int(rand * num_transforms);
        mat4 transform_matrix = transform_buffer.transforms[transform_index].matrix;
        current_pos = transform_matrix * current_pos;

        // --- STEP 2: NON-LINEAR SPIRAL transform ---
        float dist_from_center = length(current_pos.xz);
        float twist_angle = dist_from_center * u_twist_strength;
        float s = sin(twist_angle);
        float c = cos(twist_angle);
        mat4 spiral_rotation = mat4(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        current_pos = spiral_rotation * current_pos;
        current_pos.xz *= u_spiral_strength;
        current_pos.y *= 0.95; 

        // --- STEP 3: NEW NON-LINEAR SPHERICAL VARIATION ---
        // Calculate the squared distance from the origin
        float r2 = dot(current_pos.xyz, current_pos.xyz);
        
        // Avoid division by zero if the point is at the origin
        if (r2 < 1.0e-6) r2 = 1.0e-6;

        // The spherical variation formula: p_new = p_old / r^2
        vec4 spherical_pos = vec4(current_pos.xyz / r2, 1.0);

        // Blend between the position *before* the variation and the *after* position
        // A strength of 0.0 does nothing, 1.0 applies it fully.
        current_pos = mix(current_pos, spherical_pos, u_spherical_strength);

        seed += 0.1;
    }

    point_buffer.points[id] = current_pos;
}
