#version 430 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct AffineTransform {
    mat4 matrix;
};

layout(std430, binding = 0) readonly buffer TransformsBuffer {
    AffineTransform transforms[];
} transform_buffer;

layout(std430, binding = 1) writeonly buffer PointsBuffer {
    vec4 points[];
} point_buffer;

// Uniforms
uniform float u_time;
uniform int u_iterations;
uniform int u_num_base_transforms;
uniform float u_interpolation_factor;

// Parameters for Fractal A
uniform float u_twist_A;
uniform float u_spiral_A;
uniform float u_spherical_A;

// Parameters for Fractal B
uniform float u_twist_B;
uniform float u_spiral_B;
uniform float u_spherical_B;


float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= point_buffer.points.length()) {
        return;
    }

    float twist_strength = mix(u_twist_A, u_twist_B, u_interpolation_factor);
    float spiral_strength = mix(u_spiral_A, u_spiral_B, u_interpolation_factor);
    float spherical_strength = mix(u_spherical_A, u_spherical_B, u_interpolation_factor);

    vec2 seed = vec2(id, u_time);
    vec4 current_pos = vec4(random(seed) * 2.0 - 1.0, 
                            random(seed.yx) * 2.0 - 1.0, 
                            random(seed.xx) * 2.0 - 1.0, 1.0);
    
    for (int i = 0; i < u_iterations; ++i) {
        float rand = random(current_pos.xy + seed);
        int transform_index = int(rand * u_num_base_transforms);

        mat4 matrix_A = transform_buffer.transforms[transform_index].matrix;
        mat4 matrix_B = transform_buffer.transforms[transform_index + u_num_base_transforms].matrix;

        // --- FIX: Manually interpolate each column of the matrix ---
        mat4 transform_matrix = mat4(
            mix(matrix_A[0], matrix_B[0], u_interpolation_factor), // Column 0
            mix(matrix_A[1], matrix_B[1], u_interpolation_factor), // Column 1
            mix(matrix_A[2], matrix_B[2], u_interpolation_factor), // Column 2
            mix(matrix_A[3], matrix_B[3], u_interpolation_factor)  // Column 3
        );
        // --- END FIX ---

        current_pos = transform_matrix * current_pos;

        // Apply interpolated NON-LINEAR SPIRAL transform
        float dist_from_center = length(current_pos.xz);
        float twist_angle = dist_from_center * twist_strength;
        float s = sin(twist_angle);
        float c = cos(twist_angle);
        mat4 spiral_rotation = mat4(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        current_pos = spiral_rotation * current_pos;
        current_pos.xz *= spiral_strength;
        current_pos.y *= mix(0.95, 1.0, u_interpolation_factor); 

        // Apply interpolated NON-LINEAR SPHERICAL VARIATION
        float r2 = dot(current_pos.xyz, current_pos.xyz);
        if (r2 < 1.0e-6) r2 = 1.0e-6;
        vec4 spherical_pos = vec4(current_pos.xyz / r2, 1.0);
        current_pos = mix(current_pos, spherical_pos, spherical_strength);

        seed += 0.1;
    }

    point_buffer.points[id] = current_pos;
}
